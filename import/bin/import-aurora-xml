#!/usr/bin/env ruby

if ARGV.size == 0 or ARGV.size > 2 or ARGV.delete("-h")
  puts <<-END
  
    Usage: #{$0} [--log] aurora_xml_file [db]
    
    Read aurora_xml_file, parse according to aurora.xsd, and import into
    a database.
    
    The database is either an in-memory sqlite3 database (for testing) or
    specified by the db argument, which may be any valid database connection
    string:
    
      sqlite://foo.db
      postgres://user:password@host:port/database_name
    </out>
    Options:
    
      --log     print full SQL log to stderr
      
  END
  exit
end

if ARGV.delete("--log")
  require 'logger'
  DB.loggers << Logger.new($stderr)
end

xml_file = ARGV[0]
db_url = ARGV[1]

File.exist? xml_file or abort "no such file: #{xml_file}"
require 'rubygems'
require 'sqlite3'
require 'active_record'
require 'nokogiri'


DB = ActiveRecord::Base.establish_connection(
   :adapter => "sqlite3",
   :database  => "../db/development.sqlite3")
   
topdir = File.expand_path("../..", File.dirname(__FILE__))
modeldir = File.join(topdir, "app/models")
$LOAD_PATH.unshift modeldir

importdir = File.join(topdir, "import/import-files")
$LOAD_PATH.unshift importdir

libdir = File.join(topdir, "lib")
$LOAD_PATH.unshift libdir

require 'relteq_time'
require 'scenario_importer'


# create tables if they don't exist
#require 'db/schema'


module Aurora
  module Parser
    # +src+ can be io, string, etc.
    def parse src
      ## optionally validate
      Nokogiri.XML(src).xpath("/scenario")[0]

    end
  end
  extend Parser
  
  class Importer
    include Parser
    
    attr_reader :src
    attr_reader :scenario_xml
    attr_reader :scenario
    attr_reader :treat_as_new
    attr_reader :project_id
    
    
    def initialize src, project_id, opts = {}
      @src = src
      @opts = opts
      @project_id = project_id
    end
    
    def validate_project_id
      #p = Project.find(@project_id)
      p = 8
      if(p == nil)
        raise "The project id," + @project_id + " is not valid. You must pass a valid project id."
      end
    end
    
    # +src+ can be io, string, etc.
    # Returns the ID of the imported scenario.
    def import
      validate_project_id
      treat_as_new = @opts[:is_new] || false
      AuroraModelClassMethods::set_treat_as_new(treat_as_new)
      scenario_xml = parse(src)
      ActiveRecord::Base.transaction do
         scenario = ScenarioImporter.create_from_xml(scenario_xml,project_id)
      end
      
      return scenario
    end
    
  end
  
  def self.remove_dev_data
    Scenario.find(:all).each {|e| e.destroy}
    InitialConditionSet.find(:all).each {|e| e.destroy}
    InitialCondition.find(:all).each {|e| e.destroy}
    DemandProfileSet.find(:all).each {|e| e.destroy}
    DemandProfile.find(:all).each {|e| e.destroy}
    CapacityProfileSet.find(:all).each {|e| e.destroy}
    CapacityProfile.find(:all).each {|e| e.destroy}
    SplitRatioProfileSet.find(:all).each {|e| e.destroy}
    SplitRatioProfile.find(:all).each {|e| e.destroy}
    ControllerSet.find(:all).each {|e| e.destroy}
    LinkController.find(:all).each {|e| e.destroy}
    NetworkController.find(:all).each {|e| e.destroy}
    NodeController.find(:all).each {|e| e.destroy}
    EventSet.find(:all).each {|e| e.destroy}
    Event.find(:all).each {|e| e.destroy}
    Network.find(:all).each {|e| e.destroy}
    Node.find(:all).each {|e| e.destroy}
    Link.find(:all).each {|e| e.destroy}
    Route.find(:all).each {|e| e.destroy}
    Sensor.find(:all).each {|e| e.destroy}
    VehicleType.find(:all).each {|e| e.destroy}
    RouteLink.find(:all).each {|e| e.destroy}
  end
  
  def self.import src, project_id,opts = {}
    Importer.new(src,project_id,opts).import
  end
  
  #using test.xml for now. 
  def self.verify_import_tests(project_id,t)
    sum = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]

    n = Network.find_all_by_project_id(project_id)
    t["networks"] = n.count.to_s
   
    n.each do |elem| 
      sum[0] = sum[0] + elem.nodes.count 
      sum[1] = sum[1] + elem.links.count 
      sum[2] = sum[2] + elem.sensors.count 
      sum[3] = sum[3] + elem.routes.count 
      elem.routes.each {|r| sum[4] = sum[4] + r.route_links.count }
      sum[5] = sum[5] + elem.demand_profile_sets.count
      sum[6] = sum[6] + elem.capacity_profile_sets.count
      sum[7] = sum[7] + elem.split_ratio_profile_sets.count
      sum[8] = sum[8] + elem.initial_condition_sets.count
      sum[9] = sum[9] + elem.controller_sets.count
      sum[10] = sum[10] + elem.event_sets.count
      elem.controller_sets.each {|cs| sum[11] = sum[11] + cs.controllers.count}
      elem.event_sets.each {|e| sum[12] = sum[12] + e.events.count}
      elem.demand_profile_sets.each { |s| sum[13] = sum[13] + s.demand_profiles.count}
      elem.capacity_profile_sets.each{ |s| sum[14] = sum[14] + s.capacity_profiles.count}
      elem.split_ratio_profile_sets.each{ |s| sum[15] = sum[15] + s.split_ratio_profiles.count}
      elem.initial_condition_sets.each{ |s| sum[16] = sum[16] + s.initial_conditions.count}      
    end 
    
    s = Scenario.find_all_by_project_id(project_id)
    t["scenario"] = s.count.to_s
    s.each {|scen| sum[17] = sum[17] + scen.vehicle_types.count}
  
    t["nodes"] = sum[0].to_s
    t["links"] = sum[1].to_s
    t["sensors"] = sum[2].to_s
    t["routes"] = sum[3].to_s    
    t["routelinks"] = sum[4].to_s
    t["demand_profile_sets"] = sum[5].to_s
    t["capacity_profile_sets"] = sum[6].to_s 
    t["split_ratio_profile_sets"] = sum[7].to_s
    t["initial_condition_sets"] = sum[8].to_s
    t["controller_sets"] = sum[9].to_s
    t["event_sets"] = sum[10].to_s
    t["controllers"] = sum[11].to_s
    t["events"] = sum[12].to_s
    t["demand_profiles"] = sum[13].to_s
    t["capacity_profiles"] = sum[14].to_s
    t["split_ratio_profiles"] = sum[15].to_s
    t["initial_conditions"] = sum[16].to_s
    
    t["vehicle types"] = sum[17]
    t
    
 
    
  end
end

test_results = Hash.new
project_id = 8
Aurora.remove_dev_data
sc_id = Aurora.import(File.read(xml_file),project_id, {:is_new => true})
sc_id = Aurora.import(File.read(xml_file),project_id, {:is_new => false})
sc_id = Aurora.import(File.read(xml_file),project_id, {:is_new => false})

test_results = Aurora.verify_import_tests(project_id,test_results)

test_results.each do|object,value|
  p "#{object}: #{value}"
end

p "Import Finished"